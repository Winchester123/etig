use std::thread;
use std::sync::{Arc, Mutex};
use std::io;
use std::io::{BufReader,BufRead};
use std::fs::File;
use std::path::Path;
use std::sync::mpsc;
use std::collections::VecDeque;
use std::time::Duration;
extern crate time;

//Main Parallel

fn timestamp () -> f64 {
    let timespec = time::get_time();
    // 1459440009.113178
    let mills: f64 = timespec.sec as f64 + (timespec.nsec as f64 / 1000.0 / 1000.0 / 1000.0 );
    mills
}

pub fn input(mat : & mut [[i64;5000];5000], n:i64) -> bool{
	let mut v:Vec<Vec<i64>> = Vec::new();
	for i in 0..n{
		let mut v1:Vec<i64> = Vec::new(); 
		for j in 0..n{
			v1.push(mat[i as usize][j as usize]);
		}	
		v.push(v1);
	}

	let mut n1:i64 = 10;
	
	let mut n2:i64 = 11;

	let mut res: bool = findTheNode(&v, n1, n2);
	return res;
}

fn findTheNode(mut v : &Vec<Vec<i64>>, nodeA:i64, nodeB:i64)-> bool{
	let mut visited:Vec<i64> = Vec::new();
	let mut queue:VecDeque<i64> = VecDeque::new();
	let mut var:bool;
	let processor:usize = 4;
	let mut graph: Vec<Vec<i64>> = Vec::new();
	
	println!("Number of Nodes Taken:\t{:?}",v.len()); 
       println!("Parallel Version");
	for vec in v{
		let mut vv:Vec<i64> = Vec::new();
		for i in 0..vec.len(){
			vv.push(vec[i]);
		}
		graph.push(vv);
	}
    

    queue.push_back(nodeA);
    visited.push(nodeA);
    let mut k:usize = 0;
    let time1 = timestamp();

    loop {
         let mut node = queue[k];
         //println!("k: {}",k);
         //println!("Node Out:: {}",node);
         k = k + 1;

         if(queue.len() - k) >= processor{
            break;
         }
         
         if node == nodeB {
            //println!("Found Node::{}, actually: {}", node,nodeB);
	 	let time2 = timestamp();
		let diff = time2-time1;
		println!("Time Taken:\t{:?}", diff);
             	return true;
         }

         let mut i:i64 = 0;
         for vector in v{
            if i == node {//go the current node here okay actually::
                let mut ff:i64 = 0;
                //println!("vector");
                for s in vector{
                    //print!("{} ", s);
                }
                for j in vector{//now check if already visited:::
                   // println!("J: {}", j);
                    let mut flag:i64 = 0;
                    for k in &visited {
                        if *k == ff {
                            flag = 1;
                            break;
                        }
                    }
                    //println!("i:{},j:{}",i,j);
                    if flag == 0 && *j == 1{
                        queue.push_back(ff);
                       // println!("Pudhef");
                        visited.push(ff);
                    }
                    ff = ff + 1;
                }
            }
            i = i + 1;
         }
     }
     //println!("Outttt: {}", queue.len());
     for i in 0..k{
     	queue.pop_front();
     }

     //println!("Outttt: {}", queue.len());
     // Got one iteration only and after that the loop ends
     //from now start thread programming
    let  graph1 = Arc::new(Mutex::new(v));
    let nVisit = Arc::new(Mutex::new(visited));
    let nqueue = Arc::new(Mutex::new(queue));
    let cnt:i64 = 0;
    let mut cntr = Arc::new(Mutex::new(cnt));
    let mut handles = Vec::new();
    let tar = Arc::new(Mutex::new(nodeB));
    let mut kk:Vec<i64> = Vec::new();
    kk.push(-1);
    let result = Arc::new(Mutex::new(kk));

    for adi in 0..processor{
    	
    	let mut out = nqueue.clone();
    	let mut temp = nVisit.clone();
    	let mut temp1 = tar.clone();
    	let mut temp2 = graph.clone();
        let mut res = result.clone();

        let handle = thread::spawn(move || unsafe {
           // let mut rqueue = out.lock().unwrap();
            //let mut rvisited = temp.lock().unwrap();
            //let mut arr = temp1.lock().unwrap();
            
            //let mut rgraph = graph.lock().unwrap();
            let x = out.lock().unwrap().pop_front();
            let mut num:i64 = 0;
            let mut flag = -1;
            loop{
                
              // println!("cnt:: {}",adi);
                let mut x = out.lock().unwrap().pop_front();
                let mut node:i64 = 0;
                let mut te = 0;
                match x{
                    Some(d) => node = d,
                    None => te = 1
                }

                if out.lock().unwrap().len() == 0{
                    flag = 0;
                    break;
                }

                if node == nodeB {
                    flag = 1;
                    res.lock().unwrap()[0] = 1;
		    let time2 = timestamp();
		    let diff = time2-time1;
		    println!("Time Taken:\t{:?}", diff);
		    println!("The Nodes are Connected");
                    break;
                }
                let mut i:i64 = 0;
                for vector in &temp2{
                    if i == node {//go the current node here okay actually::
                        let mut ff:i64 = 0;
                        //println!("vector");
                        for s in vector{
                            //print!("{} ", s);
                        }
                        for j in vector{//now check if already visited:::
                        // println!("J: {}", j);
                            let mut flag:i64 = 0;
                            for k in temp.lock().unwrap().iter() {
                                if *k == ff {
                                    flag = 1;
                                    break;
                                }
                            }
                            //println!("i:{},j:{}",i,j);
                            if flag == 0 && *j == 1{
                                out.lock().unwrap().push_back(ff);
                                // println!("Pudhef");
                                temp.lock().unwrap().push(ff);
                            }
                            ff = ff + 1;
                        }
                    }
                    i = i + 1;
                }
            }            
        });
        handles.push(handle);
    }
    
    for h in handles {
        h.join().unwrap();
    }

    //println!("Returung {},{},{}", nodeA, nodeB, result.lock().unwrap()[0]);

    if result.lock().unwrap()[0] == 1{
        return true;
    }

    return false;
}

/*fn main(){

    let path = Path::new("Input.txt");
    let mut file = BufReader::new(File::open(&path).unwrap());

    let mut input_text = &mut String::new();
	file.read_line(input_text);
	
    let mut trimmed = input_text.trim();
    let mut m: i64 = trimmed.parse().expect("can't parse number");
    
    let mut input_text = &mut String::new();
	file.read_line(input_text);
	
    let mut trimmed = input_text.trim();
    let mut n: i64 = trimmed.parse().expect("can't parse number");

    let mut v: Vec<Vec<i64>> = Vec :: new();
    let size = v.len();

    let mut i:i64 = 0;
    let mut mat:[[i64;5000];5000] = [[0; 5000]; 5000];
    
    loop{
        
    	let mut v1:Vec<i64> = Vec::new();
    	let mut j:i64=0;
    	loop{
    		let mut input_text = &mut String::new();
			file.read_line(input_text);
			
    		let mut trimmed = input_text.trim();
    		let mut num: i64 = trimmed.parse().expect("can't parse number");
    		v1.push(num);
		mat[i as usize][j as usize] = num;
    		j = j +1;
    		if j==n {
    		    break;
    		}
    	}
    	v.push(v1);
    	i = i+1;
    	if i==m {
    	   break;
    	}
    }
    
    let mut input_text = &mut String::new();
    file.read_line(input_text);
  
    let mut trimmed = input_text.trim();
    let mut nodeA: i64 = trimmed.parse().expect("can't parse number");

    let mut input_text = &mut String::new();
    file.read_line(input_text);

    let mut trimmed = input_text.trim();
    let mut nodeB: i64 = trimmed.parse().expect("can't parse number");

    //println!("Main {},{}",nodeA,nodeB);
    
    let ts = timestamp();
    
    let res:bool = input(& mut mat,m);
    //let res:bool = findTheNode(&v,nodeA, nodeB);
	
    let time2 = timestamp();
    let t = time2 - ts;

//    println!("Time Taken:\t {:?}", t);
    
    if res == true {
  //      println!("The Given Nodes are connected");
    }else{
   // 	println!("The Given Nodes are not connected");
    }

}*/
